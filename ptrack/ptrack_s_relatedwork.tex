\section{Related Work}

\subsection{Feature Extraction and Tracking}

Feature extraction and tracking are two closely related problems in feature-based visualization. Conventional approaches extract features from individual time steps and then associate them between consecutive time steps. Silver and Wang \cite{Silver:1997:TVT:614266.614369} defined threshold connected components as their features, and tracked overlapped features by calculating their differences.
%Octree was employed in their method to speed up the performance and the criteria they used were domain dependent. 
Reinders~\cite{Reinders2001} introduced a prediction verification tracking technique that calculates a prediction by linear extrapolation based on the previous feature path, and a candidate will be added to the path if it corresponds to that prediction. Ji and Shen \cite{Ji2003} introduced a method to track local features from time-varying data by using higher-dimensional iso-surfacing. They also used a global optimization correspondence algorithm to improve the robustness of feature tracking \cite{Ji2006}. Caban et al. \cite{Caban2007} estimated a tracking window and compared feature distance of textural properties to find the best match within the window. Bremer et al. \cite{Bremer2007} described two topological feature tracking methods where one employs Jacobi sets to track critical points and the other uses distance measures on graphs to track channel structures.
%Most of the aforementioned methods extract features from each time step independently and then apply correspondence calculations. This could become very slow when the data size becomes large. 
Muelder and Ma \cite{Muelder2009} proposed a prediction-correction approach that first predicts feature region based on the centroid location of that in previous time steps, and then corrects the predicted region by adjusting the surface boundaries via region growing and shrinking. This approach is appealing because of its computing efficiency and the reliability in an interactive system.

\subsection{Parallel Feature Extraction and Tracking}

To boost the speed for feature tracking in data-distributed applications, Chen et al.~\cite{Chen03realtime} introduced a two stage partial-merge strategy using the master-slave paradigm. The slaves first exchange local connectivity information using Binary-tree merge, and then a visualization host collects and correlates the local information to generate the global connectivity. This approach is not scalable since half of the processors will become idle after each merge. It is also unclear how the host can efficiently collect local connectivity information from the slaves, since gathering operation can be expensive given a large number of processors.

\subsection{Parallel Graph Algorithm and Applications}

Graph-based algorithms have long been studied and used for a wide range of applications, typically along the line of divide-and-conquer approaches. Grundmann et al.~\cite{36247} recently proposed a hierarchical graph-based approach for video segmentation, a closely related research topic to 3D flow feature extraction as video can be treated as a space-time volume of image data~\cite{Klein2002}. In their work, a connected sequence of time-axis-aligned subsets of cubic image volumes are assigned to a set of corresponding processors, and incident regions are merged if they are inside the volumes window. Incident regions on window boundary are first marked as ambiguous and later connected by merging neighboring window to a larger window, which consists of the unresolved regions form both window on their common boundary. This approach is not applicable for memory intensive situation since the allocated volume size before merging might already reaches the memory capacity. Liu and Sun \cite{Liu2010} proposed a parallelization of the graph-cuts optimization algorithm~\cite{Boykov2004}, in which data are uniformly partitioned and then are adaptively merged to achieve fast graph-cuts. These approaches are suitable for shared-memory but not message-passing parallelization due to their frequent shifting on data ranges.
% \textcolor{red}{Not enough, need to read more.} 